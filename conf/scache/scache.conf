scache.master.ip=0.0.0.0
scache.master.port=16388
scache.client.port=15678
scache.block.fetching.retry=5
scache.memory.offHeap.size=1024m

# Tiered storage within ScacheClient:
#   - Tier 1: on-heap (DRAM)
#   - Tier 2: off-heap (CXL; can be NUMA-bound)
#   - Tier 3: disk (SCACHE_HOME/tmp)
#
# When enabled, BlockManager will try to store blocks in tier 1 first, then tier 2, then disk.
# It will also demote evicted tier-1 blocks into tier 2 before spilling to disk.
#
#scache.storage.tiered.enabled=true
#scache.storage.tiered.offHeap.enabled=true
#scache.storage.tiered.disk.enabled=true
#
# Optional: bind tier-2 (off-heap) allocations to a NUMA node (CXL simulation).
# Requires building `native/libscache_numa.so` and adding it to `java.library.path`.
#
#scache.memory.offHeap.numaNode=-1

# Optional: disable data-plane network transfers between SCache clients (remote fetch / replication).
# Useful for single-host CXL/NUMA experiments where cross-node shuffle is modeled as remote-NUMA
# memory rather than TCP.
#
#scache.storage.network.enabled=false

# Shared CXL (fsdax) pool for cross-node shuffle blocks (no client-to-client TCP).
#
# When enabled (and using daemon IPC backend=pool), non-local-consumer shuffle blocks can be
# written directly into a single shared file-backed pool visible to all nodes. The master
# allocates unique (offset,length) slices and records block->slice metadata; reduce hosts then
# read from this shared pool on demand.
#
#scache.storage.cxl.shared.enabled=true
#scache.storage.cxl.shared.pool.path=/mnt/cxl/scache-shared.pool
#scache.storage.cxl.shared.pool.size=1024g
#scache.storage.cxl.shared.pool.align=4096

# When true (default), daemon enqueues putBlock work asynchronously. For "no Spark shuffle files"
# experiments, set to false so Spark map tasks don't finish before blocks exist in SCache.
#scache.daemon.putBlock.async=true

# Daemon <-> client IPC (shuffle block bytes) settings.
#
# backend:
#   - files (default): daemon and client exchange blocks via per-block IPC files.
#   - pool           : daemon and client share a single mmap'ed pool file (offset/len),
#                      which can later be placed on a DAX-mounted path (fsdax/devdax wrapper file).
#
# mode:
#   - remote (default): daemon writes IPC file itself, then RPC-notifies client to read.
#   - local           : daemon asks client to prepare/pretouch IPC file first (helps NUMA placement).
#   - auto            : choose per block by consumer host (reduce assignment):
#                       if this host is the assigned reduce host -> dir.local, else -> dir.remote.
#
# dir (absolute paths recommended):
#   - scache.daemon.ipc.dir.remote : disk-backed dir for daemon->client IPC
#   - scache.daemon.ipc.dir.local  : tmpfs dir (e.g. /dev/shm/...) for local-consumer blocks
#   - scache.daemon.ipc.dir.get    : client->daemon IPC dir for GetBlock (defaults to dir.local)
#   - scache.daemon.ipc.dir        : legacy fallback for dir.remote
#
# pretouch (helps NUMA placement):
#   - scache.daemon.ipc.pretouch          : when true, client touches each page of the prepared IPC
#                                          region before daemon writes (works for backend=files+dir.local
#                                          and backend=pool slices)
#   - scache.daemon.ipc.pretouch.pageSize : stride in bytes (default 4096)
#
# pool (used when backend=pool):
#   - scache.daemon.ipc.pool.path     : path to a single shared pool file (mmap'ed by both sides)
#   - scache.daemon.ipc.pool.size     : initial size if file does not exist / needs extension
#   - scache.daemon.ipc.pool.mapChunk : mmap chunk size (<= 2g), blocks won't cross chunk boundary
#   - scache.daemon.ipc.pool.align    : allocation alignment in bytes (default 4096)
#   - scache.daemon.ipc.pool.zeroCopy.put : when true, the client stores the pool slice directly
#                                          as the cached bytes (no heap byte[] copy). This is only
#                                          used for serialized MEMORY_ONLY blocks.
#
#scache.daemon.ipc.backend=files
#scache.daemon.ipc.mode=auto
#scache.daemon.ipc.dir.remote=/home/yxz/SCache/tmp
#scache.daemon.ipc.dir.local=/dev/shm/scache-ipc
#scache.daemon.ipc.dir.get=/dev/shm/scache-ipc
#scache.daemon.ipc.prepare=true
#scache.daemon.ipc.pretouch=false
#scache.daemon.ipc.pretouch.pageSize=4096
#
# Example (single pool file):
#scache.daemon.ipc.backend=pool
#scache.daemon.ipc.pool.path=/dev/shm/scache-ipc.pool
#scache.daemon.ipc.pool.size=1024m
#scache.daemon.ipc.pool.mapChunk=256m
#scache.daemon.ipc.pool.align=4096
#
# StorageLevel used when the client ingests blocks from daemon.
#scache.daemon.putBlock.storageLevel.local=MEMORY_ONLY
#scache.daemon.putBlock.storageLevel.remote=DISK_ONLY
#scache.daemon.putBlock.storageLevel=MEMORY_ONLY
